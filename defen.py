board = list(range(1, 11))  # колличество клеток в сетке
wins_comb = [(1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 4, 7), (2, 5, 8), (3, 6, 9), (1, 5, 9),(3, 5, 7)]  # Выигрышные комбинации # Пишу комбинации в виде кортежа, так как это неизменяемый тип данных.
str_ = "123456789"


def setka():
    print("_______________")
    for index in range(3):
        print(f' | {board[0 + index * 3]} | {board[1 + index * 3]} | {board[2 + index * 3]} |')
    print("_______________")  # Этот принт входит в цикл for


# В 9 строке мы пронумеровывыем сетку (1 -10) и распечатывем ее. Мы обращаемся -->
# к списку board (1 -10)  и с помощью цикла for мы печатаем 3 строки с индекс-значениями board.
# Если мы берем первый цикл, то index = 0, поэтому индекс списка board будет 0. Следовательно, единица (1) -->
# будет распечатана в нашей сетке, так как индексация начинается с 0 и т.д

def take_input(symbol):  # Здесь мы принимаем число от игрока и проверяем его на актуальность
    while True:
        value = input(
            "Выбери клетку, куда поставить " + symbol + ":")  # Значение, которое вносит игрок является типом данных str
        if not value in str_:
            print("Такой клетки не существует, попробуй выбрать другое значение клетки")
            continue
        value = int(value)
        if str(board[
                   value - 1]) in "XO":  # Мы переводим value из str в int для того, чтобы проверить занята эта клетка или нет в списке board через индекс.
            print("Эта клетка уже занята, попробуй выбрать другое значение клетки")
            continue  # Возвращаемся в самое начало для проверки нового значения через все условия.
        board[value - 1] = symbol  # Присваиваем нашей клетке символ X или O
        break  # Выходим их цикла


def wins_combo():
    for index in wins_comb:
        if (board[index[0] - 1]) == (board[index[1] - 1]) == (board[index[2] - 1]):
            return board[index[1] - 1]
    else:
        return False
